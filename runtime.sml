(* April 1989, Jussi Rintanen, Helsinki University of Technology *)

(* This is the signature of a specification generated by ML-Twig *)

signature TWIG_SPECIFICATION =
sig
  type cost
  and tree
  and result
  eqtype rule
  and symbol

  val get_subtrees: tree -> tree list
  val node_value: tree -> symbol
  val cost_less: cost * cost -> bool

  datatype skeletal = Skeleton of rule * cost * tree * skeletal list

  exception MatchAbort
  and InternalError of string

  val execute_cost: rule * tree * skeletal list -> cost
  val execute: skeletal -> result
  val getreplacement: result -> tree
  val rewriterule: rule -> bool
  val matches: rule -> int

  (* Definitions for unit rule matches and the tree pattern matching automaton *)

  eqtype state

  datatype matchtree = Chain of rule * symbol * matchtree list
  val unitmatches: symbol -> matchtree list

  val childsymbol: int -> symbol
  val initialstate: state
  val go: state * symbol -> state
  val go_f: state * symbol -> (int * rule * symbol) list
end

exception NthTail
exception Nth

fun nthtail (e, 0) = e
  | nthtail (e :: r, n) =
      nthtail (r, n - 1)
  | nthtail _ = raise NthTail
fun nth x =
  hd (nthtail x)
  handle NthTail => raise Nth | Hd => raise Nth

(* This functor maps a specification to a structure containing a complete tree
   processor program and associated definitions. *)

functor MAKEtreeprocessor(Specification: TWIG_SPECIFICATION) =
struct
  structure Spec: TWIG_SPECIFICATION = Specification

  open Spec

  exception NoCover

  fun internal s =
    raise InternalError ("FATAL:" ^ s)

  (* The structure representation implements a data type for
     maintaining information of the matching tree pattern
     matching process. The actual implementation is left
     unspecified in the signature. However, because of the
     match mode rewrite, an implementation without side effects
     is required. *)

  structure Representation:
  sig
    structure Spec: TWIG_SPECIFICATION
    type 's match =
      {rule: Spec.rule, num_matches: int, children_skeletons: 's list}
    type 's match_info = (Spec.symbol * 's match list) list
    type 's table

    val empty_table: unit -> 's table
    val new_level: 's table -> 's table
    val contribute0: 's table * int * Spec.rule * Spec.symbol -> 's table
    val contribute1: 's table * int * Spec.rule * Spec.symbol * 's -> 's table
    val get_level: 's table -> 's match_info * 's table
  end =
  struct

    (* The table is a list, where the head contains the match information
       for the current node of the user tree. The tail of the list
       contains the match information for the ancestors of the current
       node. The match information for a node is an ordered list of pairs,
       where the first member is the number of the non-terminal, to which
       the matches in the second member contribute.
         The matches for a non-terminal are in an ordered list of triples
       rule * number of matches * children skeletons. *)

    structure Spec = Spec

    open Spec

    type 's match = {rule: rule, num_matches: int, children_skeletons: 's list}
    type 's match_info = (symbol * 's match list) list
    type 's table = 's match_info list
    fun empty_table () = []
    fun new_level l = [] :: l
    fun insert0' (r: rule, nil) =
          [{rule = r, num_matches = 1, children_skeletons = []}]
      | insert0'
          ( r: rule
          , (h as {rule = r', num_matches = m', children_skeletons = s'}) :: hs
          ) =
          if r' <> r then h :: insert0' (r, hs)
          else {rule = r, num_matches = m' + 1, children_skeletons = s'} :: hs
    fun insert0 (nil, r, t: symbol) =
          [(t, [{rule = r, num_matches = 1, children_skeletons = []}])]
      | insert0 ((h as (t', a)) :: hs, r, t) =
          if t' <> t then h :: insert0 (hs, r, t)
          else (t, insert0' (r, a)) :: hs
    fun insert1' (r: rule, s, nil) =
          [{rule = r, num_matches = 1, children_skeletons = [s]}]
      | insert1'
          ( r
          , s
          , (h as {rule = r', num_matches = m', children_skeletons = s'}) :: hs
          ) =
          if r' <> r then
            h :: insert1' (r, s, hs)
          else
            {rule = r, num_matches = m' + 1, children_skeletons = s :: s'} :: hs
    fun insert1 (nil, r, t: symbol, s) =
          [(t, [{rule = r, num_matches = 1, children_skeletons = [s]}])]
      | insert1 ((h as (t', a)) :: hs, r, t, s) =
          if t' <> t then h :: insert1 (hs, r, t, s)
          else (t, insert1' (r, s, a)) :: hs
    fun contribute0 (a :: l, 1, r, t) =
          insert0 (a, r, t) :: l
      | contribute0 (a :: l, n, r, t) =
          a :: contribute0 (l, n - 1, r, t)
      | contribute0 _ = internal "run out of levels"
    fun contribute1 (a :: l, 1, r, t, s) =
          insert1 (a, r, t, s) :: l
      | contribute1 (a :: l, n, r, t, s) =
          a :: contribute1 (l, n - 1, r, t, s)
      | contribute1 _ = internal "run out of levels"
    fun get_level (a :: l) = (a, l)
      | get_level _ = internal "run out of levels"
  end

  open Representation

  (* Utility functions *)

  fun cost (Skeleton (_, c, _, _)) = c

  val rec
    insert: symbol * skeletal * (symbol * skeletal) list
            -> (symbol * skeletal) list =
    fn (i: symbol, s: skeletal, nil) => [(i, s)]
     | (i: symbol, s: skeletal, (head as (i', s')) :: rest) =>
      if i = i' then
        if cost_less (cost s, cost s') then (i, s) :: rest else head :: rest
      else
        head :: (insert (i, s, rest))

  fun build_skeleton (ar as (r: rule, t: tree, cs: skeletal list)) : skeletal =
    Skeleton (r, execute_cost ar, t, rev cs)

  (* get_closure takes four arguments. The first is a unit rule tree.
  The second is the sub-skeleton in the unit rule match. The third
  is the ir-tree of the current node, and the fourth is the list
  of skeletons generated so far. The skeleton list consists of pairs:
  the first element is the number of the non-terminal of the rule,
  and the second element is the skeleton. *)

  fun get_closure
    ( ct: matchtree list
    , ss: skeletal list
    , t: tree
    , ac: (symbol * skeletal) list
    ) : (symbol * skeletal) list =
    List.foldl
      (fn ( Chain (rule, symbol, cs: matchtree list)
          , ac': (symbol * skeletal) list
          ) => let val skel = build_skeleton (rule, t, ss)
               in get_closure (cs, [skel], t, insert (symbol, skel, ac'))
               end
               handle MatchAbort => ac') ac ct

  val rec someone: tree * skeletal * skeletal match list -> skeletal list =
    fn (tree, still_best, nil) => [still_best]
     | (tree, still_best, {rule, num_matches, children_skeletons} :: rest) =>
      if matches rule = num_matches then
        let
          val skel = build_skeleton (rule, tree, children_skeletons)
        in
          someone
            ( tree
            , if cost_less (cost skel, cost still_best) then skel
              else still_best
            , rest
            )
        end
        handle MatchAbort => someone (tree, still_best, rest)
      else
        someone (tree, still_best, rest)

  val rec still_no_one: tree * skeletal match list -> skeletal list =
    fn (tree, nil) => nil
     | (tree, {rule, num_matches, children_skeletons} :: rest) =>
      if matches rule = num_matches then
        someone (tree, build_skeleton (rule, tree, children_skeletons), rest)
        handle MatchAbort => still_no_one (tree, rest)
      else
        still_no_one (tree, rest)

  val leave_best_alone: tree * skeletal match list -> skeletal list =
    fn (tree, nil) => internal "matcher state inconsistent. lba."
     | (tree, l) => still_no_one (tree, l)

  fun skeletons_of (state: state, node: tree, table: skeletal table) :
    skeletal table * (symbol * skeletal) list =
    let
      val (t: skeletal table, s: (symbol * skeletal) list) =
        case get_subtrees node of
          nil =>
            let
              val table' =
                List.foldl
                  (fn ((h: int, r: rule, n: symbol), t) =>
                     contribute0 (t, h - 1, r, n)) table
                  (go_f (state, node_value node))
            in
              ( table'
              , get_closure ((unitmatches o node_value) node, [], node, [])
              )
            end
        | ls =>
            let
              val state' = go (state, node_value node)
              val (table, _) =
                List.foldl
                  (fn (l: tree, (t: skeletal table, i: int)) =>
                     let
                       val state'' = go (state', childsymbol i)
                       val (t': skeletal table, ss: (symbol * skeletal) list) =
                         skeletons_of (state'', l, t)
                     in
                       ( List.foldl
                           (fn ((r: symbol, s: skeletal), t'': skeletal table) =>
                              let
                                val finals: (int * rule * symbol) list =
                                  go_f (state'', r)
                              in
                                List.foldl
                                  (fn ((h: int, r: rule, n: symbol), t''') =>
                                     contribute1 (t''', h - 1, r, n, s)) t''
                                  finals
                              end) t' ss
                       , i + 1
                       )
                     end) (new_level table, 1) ls
              val (toplevel, table') = get_level table
            in
              ( table'
              , let
                  val unclosurized =
                    List.foldl
                      (fn ((_, nil), l) => l
                        | ((n, [e]), l) => (n, e) :: l
                        | _ => internal "inconsistency. 01l") nil
                      (List.map
                         (fn (n: symbol, sl: skeletal match list) =>
                            (n, leave_best_alone (node, sl))) toplevel)
                in
                  List.foldl
                    (fn ((n, s), al) =>
                       get_closure (unitmatches n, [s], node, al)) unclosurized
                    unclosurized
                end
              )
            end
    in
      case s of
        [] => (t, [])
      | [(_, S as Skeleton (r, _, _, _))] =>
          if rewriterule r then
            skeletons_of (state, (getreplacement o execute) S, table)
          else
            (t, s)
      | (_, sk) :: rest =>
          let
            val best as Skeleton (r, _, _, _) =
              List.foldl
                (fn ((_, s), bs) =>
                   if cost_less (cost s, cost bs) then s else bs) sk rest
          in
            if rewriterule r then
              skeletons_of (state, (getreplacement o execute) best, table)
            else
              (t, s)
          end
    end

  fun translate (t: tree) : result =
    let
      val (_, closure) = skeletons_of (initialstate, t, empty_table ())
      val skeletal =
        case closure of
          (_, s) :: t =>
            List.foldl
              (fn ((n, s), bs) => if cost_less (cost s, cost bs) then s else bs)
              s t
        | nil => raise NoCover
    in
      execute skeletal
    end

end
